// General
"whisperax" = "WhisperAX";
"no_audio_input" = "No Audio Input";

// Tabs
"tab_transcribe" = "Transcribe";
"tab_stream" = "Stream";

"transcribe" = "Transcribe";
"stream" = "Stream";

// Model Management
"load_model" = "Load Model";
"compute_units" = "Compute Units";
"audio_encoder" = "Audio Encoder";
"text_decoder" = "Text Decoder";
"cpu" = "CPU";
"gpu" = "GPU";
"neural_engine" = "Neural Engine";
"specializing_text" = "Specializing %@ for your device...\nThis can take several minutes on first load";


// Controls
"reset" = "Reset";
"settings" = "Settings";
"from_file" = "FROM FILE";
"record" = "RECORD";
"waiting_for_speech" = "Waiting for speech...";
"encoder_runs" = "Encoder runs: %d";
"decoder_runs" = "Decoder runs: %d";



// Settings
"source_language" = "Source Language";
"show_timestamps" = "Show Timestamps";
"hint_show_timestamps" = "Toggling this will include/exclude timestamps in both the UI and the prefill tokens.\nEither <|notimestamps|> or <|0.00|> will be forced based on this setting unless \"Prompt Prefill\" is de-selected.";
"special_characters" = "Special Characters";
"hint_special_characters" = "Toggling this will include/exclude special characters in the transcription text.";
"show_decoder_preview" = "Show Decoder Preview";
"hint_show_decoder_preview" = "Toggling this will show a small preview of the decoder output in the UI under the transcribe. This can be useful for debugging.";
"prompt_prefill" = "Prompt Prefill";
"hint_prompt_prefill" = "When Prompt Prefill is on, it will force the task, language, and timestamp tokens in the decoding loop. \nToggle it off if you'd like the model to generate those tokens itself instead.";
"cache_prefill" = "Cache Prefill";
"hint_cache_prefill" = "When Cache Prefill is on, the decoder will try to use a lookup table of pre-computed KV caches instead of computing them during the decoding loop. \nThis allows the model to skip the compute required to force the initial prefill tokens, and can speed up inference";
"chunking_strategy" = "Chunking Strategy";
"hint_chunking_strategy" = "Select the strategy to use for chunking audio data. If VAD is selected, the audio will be chunked based on voice activity (split on silent portions).";
"none" = "None";
"vad" = "VAD";
"starting_temperature" = "Starting Temperature:";
"hint_starting_temperature" = "Controls the initial randomness of the decoding loop token selection.\nA higher temperature will result in more random choices for tokens, and can improve accuracy.";
"max_fallback_count" = "Max Fallback Count:";
"hint_max_fallback_count" = "Controls how many times the decoder will fallback to a higher temperature if any of the decoding thresholds are exceeded.\n Higher values will cause the decoder to run multiple times on the same audio, which can improve accuracy at the cost of speed.";
"compression_check_tokens" = "Compression Check Tokens";
"hint_compression_check_tokens" = "Amount of tokens to use when checking for whether the model is stuck in a repetition loop.\nRepetition is checked by using zlib compressed size of the text compared to non-compressed value.\n Lower values will catch repetitions sooner, but too low will miss repetition loops of phrases longer than the window.";
"max_tokens_per_loop" = "Max Tokens Per Loop";
"hint_max_tokens_per_loop" = "Maximum number of tokens to generate per loop.\nCan be lowered based on the type of speech in order to further prevent repetition loops from going too long.";
"silence_threshold" = "Silence Threshold";
"hint_silence_threshold" = "Relative silence threshold for the audio. \n Baseline is set by the quietest 100ms in the previous 2 seconds.";
"experimental" = "Experimental";
"eager_streaming_mode" = "Eager Streaming Mode";
"hint_eager_streaming_mode" = "When Eager Streaming Mode is on, the transcription will be updated more frequently, but with potentially less accurate results.";
"token_confirmations" = "Token Confirmations";
"hint_token_confirmations" = "Controls the number of consecutive tokens required to agree between decoder loops before considering them as confirmed in the streaming process.";
"decoding_options" = "Decoding Options";
"done" = "Done";

// Toolbar
"copy_text" = "Copy Text";

// model 说明
"unloading" = "Unloading";
"unloaded" = "Unloaded";
"loading" = "Loading";
"loaded" = "Loaded";
"specializing" = "Specializing";
"specialized" = "Specialized";
"downloading" = "Downloading";
"downloaded" = "Downloading";

// 解码类型
"decode_type_transcribe" = "Transcribe";
"decode_type_translate" = "Translate";


// 语言
"language_english" = "english";
"language_chinese" = "chinese";
"language_german" = "german";
"language_spanish" = "spanish";
"language_russian" = "russian";
"language_korean" = "korean";
"language_french" = "french";
"language_japanese" = "japanese";
"language_portuguese" = "portuguese";
"language_turkish" = "turkish";
"language_polish" = "polish";
"language_catalan" = "catalan";
"language_dutch" = "dutch";
"language_arabic" = "arabic";
"language_swedish" = "swedish";
"language_italian" = "italian";
"language_indonesian" = "indonesian";
"language_hindi" = "hindi";
"language_finnish" = "finnish";
"language_vietnamese" = "vietnamese";
"language_hebrew" = "hebrew";
"language_ukrainian" = "ukrainian";
"language_greek" = "greek";
"language_malay" = "malay";
"language_czech" = "czech";
"language_romanian" = "romanian";
"language_danish" = "danish";
"language_hungarian" = "hungarian";
"language_tamil" = "tamil";
"language_norwegian" = "norwegian";
"language_thai" = "thai";
"language_urdu" = "urdu";
"language_croatian" = "croatian";
"language_bulgarian" = "bulgarian";
"language_lithuanian" = "lithuanian";
"language_latin" = "latin";
"language_maori" = "maori";
"language_malayalam" = "malayalam";
"language_welsh" = "welsh";
"language_slovak" = "slovak";
"language_telugu" = "telugu";
"language_persian" = "persian";
"language_latvian" = "latvian";
"language_bengali" = "bengali";
"language_serbian" = "serbian";
"language_azerbaijani" = "azerbaijani";
"language_slovenian" = "slovenian";
"language_kannada" = "kannada";
"language_estonian" = "estonian";
"language_macedonian" = "macedonian";
"language_breton" = "breton";
"language_basque" = "basque";
"language_icelandic" = "icelandic";
"language_armenian" = "armenian";
"language_nepali" = "nepali";
"language_mongolian" = "mongolian";
"language_bosnian" = "bosnian";
"language_kazakh" = "kazakh";
"language_albanian" = "albanian";
"language_swahili" = "swahili";
"language_galician" = "galician";
"language_marathi" = "marathi";
"language_punjabi" = "punjabi";
"language_sinhala" = "sinhala";
"language_khmer" = "khmer";
"language_shona" = "shona";
"language_yoruba" = "yoruba";
"language_somali" = "somali";
"language_afrikaans" = "afrikaans";
"language_occitan" = "occitan";
"language_georgian" = "georgian";
"language_belarusian" = "belarusian";
"language_tajik" = "tajik";
"language_sindhi" = "sindhi";
"language_gujarati" = "gujarati";
"language_amharic" = "amharic";
"language_yiddish" = "yiddish";
"language_lao" = "lao";
"language_uzbek" = "uzbek";
"language_faroese" = "faroese";
"language_haitian_creole" = "haitian";
"language_pashto" = "pashto";
"language_turkmen" = "turkmen";
"language_nynorsk" = "nynorsk";
"language_maltese" = "maltese";
"language_sanskrit" = "sanskrit";
"language_luxembourgish" = "luxembourgish";
"language_myanmar" = "myanmar";
"language_tibetan" = "tibetan";
"language_tagalog" = "tagalog";
"language_malagasy" = "malagasy";
"language_assamese" = "assamese";
"language_tatar" = "tatar";
"language_hawaiian" = "hawaiian";
"language_lingala" = "lingala";
"language_hausa" = "hausa";
"language_bashkir" = "bashkir";
"language_javanese" = "javanese";
"language_sundanese" = "sundanese";
"language_cantonese" = "cantonese";
"language_burmese" = "burmese";
"language_valencian" = "valencian";
"language_flemish" = "flemish";
"language_haitian" = "haitian";
"language_letzeburgesch" = "letzeburgesch";
"language_pushto" = "pushto";
"language_panjabi" = "panjabi";
"language_moldavian" = "moldavian";
"language_moldovan" = "moldovan";
"language_sinhalese" = "sinhalese";
"language_castilian" = "castilian";
"language_mandarin" = "mandarin";
